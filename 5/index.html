<title>
  Quest Devblog 4
</title>
<link rel="stylesheet" type="text/css" href="../style.css">
<body>
   12-3-2023

    <p>
      For the past week, I worked on bug fixing and polishing tasks. 
    </p>
  <strong>Implementing Shadows</strong>
  <p>
    In the previous devblog, I introduced the technology behind rendering shadows for our game. 
    I checked in the script, but I did not add the script to any of the objects in the scene
    because I was unsure of how to integrate it with our external world design tool which overwrites
    any changes made in Unity each time it exports. At the studio work session, I pair-programmed
    with a member of the overworld team to ensure that they were implemented properly.
  </p>
  <p>
    The scenes have two layers. The bottom layer is the result of importing tile data from
    LDtk, the external tool, and on top of that are prefabs like houses, props, and NPCs, which
    are placed manually and not connected to the external tool. For the latter, adding shadows
    was simple, all I needed to do was add the script to the prefabs and then in all scenes that
    they were present in, shadows appeared automatically.
  </p>
  <p>
    The trees were also not particularly difficult, but it took me a while to figure out how they
    worked in order to add shadows to them. These prefabs are connected to the external tool, but they
    also have a randomizer script that runs on each import. From what I could gather by poking at it,
    there is a base prefab named "Tree" that the LDtk importer uses as a stamp. Each instance of the stamp
    is named "Tree-UUID", where UUID is a randomly generated UUID that is stable across imports. By modifying the base
    prefab to add the shadow script, all of the stamp variants get shadows. It turned out that generating the shadows
    on awake was a good idea, because it means that the shadows are always showing the correct sprite, regardless of what
    the randomizer does. Otherwise, I would need to synchronize the randomizer script with the shadow script which may not be
    trivial.
    <figure>
      <img src="shadows-forest.png" style="width:100%; max-width:600px">
      <figcaption>The Forest with shadows applied</figcaption>
    </figure>
    We decided not to have shadows for the tiles, because this technique won't work for them. The tiled backgrounds get imported
    as one object per tile type, which cover the whole area. The only way to add shadows would be to have the artists draw
    shadowed variants of every single tile, which is out of scope for this project. 
  </p>
   
  
  <strong>Trying to debug disappearing objects</strong>
  <p>
    In the Counter Attack minigame, the player must successfully parry incoming projectiles to deal damage to the enemy. On the design
    doc, the game does not end when a projectile hits the player. However, for some reason, after any of the projectiles hit the player,
    all of the projectiles get destroyed. I attempted for quite a while to figure out why this was happening. 
  </p>
  <p>
    Closed-source dependencies are one of the great satans of software development, and for good reason. None of the debugging tricks 
    I use work on this particular problem with Unity. My first thought was to breakpoint inside OnDestroy, then use the call stack to
    figure out where the destroy call was originating from. However, the resulting stack trace was completely useless, consisting solely of
    the OnDestroy call and nothing else. In my own engine, my next trick would be to breakpoint inside of the object destruction mechanism
    inside the engine itself, and use conditional breakpoints to filter for the specific objects that I want. I can Step In as deep as I want
    into core engine internals and see exactly what the engine is doing at all levels. This works becuase I have all of the source code
    for both the engine and all of its libraries, so I can generate debug symbols for them. But because Unity is closed-source 
    (unless you have an enterprise license), this is impossible. I searched through forum posts and Reddit threads trying to find any
    techniques people use to find these issues, and found nothing. The only useful advice I could find was to use symbol lookup to search for every call to Destroy 
    and manually check <em>every single one</em> to find the responsible code. But even in a game as small as Project Quest, there are <em>hundreds</em>
    of Destroy calls, and for the majority of them it's not obvious what purpose they serve just by looking at the code.
  </p>
  <p>
    After banging my head against the wall with another programmer for a long time, we eventually gave up, and this bug is now a feature. This bug
    nicely illustrates the ugly side of weakly-coupled designs like the EventBus and GetAllComponents. That Destroy call could be coming from <em>anywhere</em>, and it's not clear what objects and responsibilities are owned by what. Sprinkle in a generous helping of
    referencing via the editor inspector (which is completely invisible to static analysis tools) and you can quite easily weave a multilayered, interconnected, and unsearchable noose to hang yourself with.
    Avoiding these footguns takes team-wide discipline and proper thought to how code should communicate. On projects like studio games
    (or even in the commercial game industry) where it's a mad scramble start-to-finish to ship on time, proper code design often falls by the
    wayside. Once you're tangled in the spiderweb of your own creation, it's very difficult to break free. 
  </p>
  <p>
    Despite this, I think the EventBus in particular has more positives than negatives. Even if the source of the Destroy call was from inside the event bus, being able to debug properly would at least tell me which event is responsible, greatly
    reducing the search area. 
    If anyone reading this knows tricks for finding the source of object destruction, <em>please</em> let me know. 
  </p>

  
</body>
